# **Chapter 3 - 람다 표현식**

## **람다의 특징**

- 익명

보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다. 구형해야 할 코드에 대한 걱정거리가 줄어든다

- 함수

람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.

- 전달

람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.

- 간결성

익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

### **람다 표현식**

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

- 파라미터 리스트 - 람다 바디에서 사용할 메서드 파라미터를 명시한다.
- 화살표 - 람다의 파라미터 리스트와 바디를 구분한다.
- 람다 바디 - 람다의 반환값에 해당하는 표현식이다.

## **람다의 사용**

### **함수형 인터페이스**

함수형 인터페이스는 **정확히 하나의 추상 메서드를 지정하는 인터페이스**다. 아무리 많은 디폴트 메서드가 존재하더라도 추상 메서드가 오직 하나면 함수형 인터페이스.

@FuntionalInterface는 함수형 인터페이스임을 가리키는 애노테이션이다. 만약 애노테이션을 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다.

### **함수 디스크립터**

함수형 인터페이스의 추상 메서드를 람다로 구현하였다면, 둘의 표현식 시그니처는 같다. 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.

### **실행 어라운드 패턴**

고정된 설정과 정리 과정을 두고 실제 자원을 처리하는 코드를 설정과 과정리 두 과정이 둘러싸는 형태의 패턴을 실행 어라운드 패턴(execute around pattern)이라고 부른다. 이때 실제 자원을 처리하는 코드를 파라미터화 하고 람다를 통해 동작을 전달할 수 있다.

## **함수형 인터페이스 사용**

### **Predicate<T>**

(T) → boolean

### **Consumer<T>**

(T) → void

### **Supplier<T>**

() → T

### **Function<T,R>**

(T) → R

### BinaryOperator<T>

(T, T) → T

… 더 많이 알고 싶으면 책을 보자

## **기본형 특화**

제네릭은 **참조형 타입**만 지정할 수 있다. Integer와 Long 같이 기본타입에 대하여 박싱된 타입을 통해 제네릭을 이용할 수 있지만, **오토박싱으로 인해 변환 비용이 소모된다**. 자바 8에 추가된 함수형 인터페이스는 기본형을 입출력으로 사용하는 상황에서 오토박싱 동작을 피할 수 있도록 기본형에 특화된 버전의 함수형 인터페이스를 제공한다.

<aside>
💡 오토박싱은 비용이 매우 크다! 의식적으로 피하도록 하자

</aside>

### Example

IntPredicate, LongConsumer, BooleanSupplier …

## **형식 검사, 형식 추론, 제약**

### **형식 검사**

람다가 사용되는 콘텍스트(context)를 이용해서 람다의 형식(type)을 추론할 수 있다. 어떤 콘텍스트에서 기대되는 람다 표현식의 형식을 **대상 형식(target type)**이라고 부른다. 형식검사는 다음과 같은 과정으로 진행된다.

1. 람다가 사용된 메서드의 선언을 확인한다.
2. 람다가 사용된 메서드의 파라미터로 대상 형식을 기대한다.
3. 기대하는 파라미터의 함수형 인터페이스를 파악한다.
4. 그 함수형 인터페이스의 함수 디스크립터를 묘사한다.
5. 전달받은 인수의 람다가 그 요구사항을 만족해야 한다.

### **형식 추론**

제네릭을 사용할 때 선언부에 타입 매개변수를 명시하면 생성자에서는 빈 다이아몬드 연산자로 남겨두어도 자바 컴파일러는 생성 객체의 타입을 추론할 수 있다. 람다 표현식도 마찬가지이다. 자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다.

```java
// 형식 추론을 하지 않음
Comparator<Apple> c =
	(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 형식을 추론함
Comparator<Apple> c =
	(a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

### **지역 변수 사용 및 제약**

람다 표현식에서는 익명 함수가 하는 것 처럼 자유 변수(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용할 수 있다. 이를 람다 캡처링(lamda capturing)이라 부른다. 하지만 그러려면 지역 변수는 명시적으로 final로 선언되어 있어야 하거나 실질적으로 final로 선언된 변수와 똑같이 사용되어야 한다(이후 재 할당 불가).

인스턴스 변수는 힙에 저장되는 반면 지역 변수는 스택에 위치한다. 람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면 지역 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있다. 따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴것이다.

<aside>
💡 이 내용이 햇갈린다면 앞의 병렬성 공부!

</aside>

## **메서드 참조**

명시적으로 메서드 명을 참조함으로써 가독성을 높일 수 있다. 메서드 참조는 메서드명 앞에 구분자(::)를 붙이는 방식으로 사용할 수 있다. Class::method 형식을 취한다. 메서드 참조는 세 가지 유형으로 구분할 수 있다.

1. 정적 메서드 참조 Ex) Integer::parseInt
2. 다양한 형식의 인스턴스 메서드 참조 Ex) String::length
3. 기존 객체의 인스턴스 메서드 참조 Ex) Apple::getWeight

또한 ClassName::new 처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.

<aside>
💡 쉽게 말하자면 **메서드 참조**는 특정 메서드만을 호출하는 **람다의 축약형**

</aside>

---

# **Chapter 4 - 스트림 소개**

## **스트림(Stream)이란 무엇인가?**

멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있는 자바 8 API에 새로 추가된 기능이다.

### 스트림의 특징

- 세부 구현은 라이브러리 내에서 처리 → 가비지 변수를 만들지 않는다.
- 선언형으로 코드를 구현할 수 있다. → 요구사항에 쉽게 대응
- 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다.

<aside>
💡 스트림 API의 특징은 선언형, 조립할 수 있음, 병렬화로 요약 가능하다.

</aside>

## **스트림의 정의**

스트림은 자세히 표현하자면 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소로 정의할 수 있다.

- 연속된 요소: 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. 주로 계산식이 주를 이룬다. 이때 연속적은 순차적으로 접근함을 의미한다.
- 소스: 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
- 데이터 처리 연산: 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원하며, 순차적으로 또는 병렬로 실행할 수 있다.

스트림의 두 가지 중요 특성

- 파이프라이닝: 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다. 그 덕에 게으름(lazyness), 쇼트서킷(short-circuiting) 같은 최적화도 얻을 수 있다.
- 내부 반복: 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 즉, **컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다**. 반면 스트림은 이론적으로 **요청할 때만 요소를 계산**하는 고정된 자료구조다. 이러한 스트림의 특성은 **게으른 생성**을 가능하게 한다.

스트림은 반복자와 마찬가지로 한 번만 탐색할 수 있다. 탐색된 스트림의 요소는 소비된다.

## **중간 연산과 최종 연산**

스트림은 연결할 수 있는 스트림 연산인 **중간 연산(intermediate operation)**과 스트림을 닫는 연산인 **최종 연산(terminal operation)**으로 구성된다.

**중간 연산**은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 연결해 질의를 만들 수 있다. 중간 연산의 가장 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무도 연산을 수행하지 않는다는 것, 즉 게으르다(lazy)는 것이다. 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리하기 때문이다.

```java
List<Stirng> names = menu.stream() // 스트림 open
		.filter(dish -> dish.getCalories > 300) // 중간 연산 시작
		.map(Dish::getname)
		.limit(3) // 중간 연산 끝, short-circuit
		.collect(toList()); // 종단 연산
```

### 스트림의 최적화 효과

1. 쇼트 서킷

모든 연산을 다 해보기 전에 조건을 만족하면 추가적인 불필요한 연산은 하지 않는다. 위의 예시에서는 limit 연산이 쇼트 서킷 연산에 해당된다. 3개의 결과를 얻은 후 앞선 filter와 map연산은 더 이상 수행할 필요가 없어 빠르게 최종 연산을 수행한다.

1. 루프 퓨전

위의 예시 코드에서 filter와 map 연산에 값을 print 하는 과정을 추가한다면 filter와 map이 다른 연산이지만 한 과정으로 병합되어 처리됨을 확인할 수 있다. 루프 퓨전은 이렇게 둘 이상의 연산이 합쳐 하나의 연산으로 처리됨을 말한다.

**최종 연산**은 스트림 파이프라인에서 결과를 도출한다. 스트림 외의 결과를 반환하는 연산을 말한다.

## [Notion](https://able-day-a94.notion.site/Week2-38e8db857237410ba34301c6dd15ad14)
