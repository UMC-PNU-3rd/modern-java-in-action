# **Chapter 9 - 리팩터링, 테스팅, 디버깅**

## **가독성과 유연성을 개선하는 리팩터링**

### **코드 가독성 개선**

- 익명 클래스를 람다 표현식으로 리팩터링하기
    - 익명 클래스에서 this는 익명 클래스 자신을 가리키지만 람다에서 this는 람다를 감싸는 클래스를 가리킨다.
    - 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있다.
    - 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해지는 반면 람다의 형식은 콘텍스트에 따라 달라진다.
- 람다 표현식을 메서드 참조로 리팩터링하기
- 명령형 데이터 처리를 스트림으로 리팩터링하기

### **코드 유연성 개선**

람다 표현식을 이용하면 동작 파라미터화(behavior parameterzation)을 쉽게 구현할 수있다. 람다 표현식을 사용하기 위해 함수형 인터페이스 적용해야 한다.

1. 조건부 연기 실행 :

코드 내부에 제어 흐름문이 복잡하게 얽힌 코드를 볼 수 있다. 불필요한 if문을 제거할 수 있으며 코드 가독성이나 캡슐화도 강화된다.

1. 실행 어라운드 :

매번 같은 준비, 종료 과정을 반복적으로 수행한다면 이를 람다로 변환할 수 있다.

## **람다로 객체지향 디자인 패턴 리팩터링하기**

### **전략 (Strategy)**

전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법이다. 전략을 구현하는 새로운 클래스를 람다 표현식을 통해 직접 전달할 수 있다.

### **템플릿 메서드 (template method)**

알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때 템플릿 메서드 디자인 패턴을 사용한다. 추상 메서드로 원하는 동작을 구현하는 곳을 람다 표현식을 통해 전달할 수 있다.

### **옵저버 (observer)**

어떤 이벤트가 발생했을 때 한 객체(subject)가 다른 객체 리스터(observer)에 자동으로 알림을 보내야 하는 상황에서 사용하는 패턴이다.

Observer 인터페이스는 새로운 트윗이 있을 때 subject가 호출할 수 있도록 notify라고 하는 하나의 메서드를 제공한다. Observer 인테페이스를 구현하는 클래스를 만드는 대신 람다 표현식을 직접
전달해서 실행할 동작을 지정할 수 있다.

하지만 옵저버가 상태를 가지며, 여러 메서드를 정의하는 등 복잡하다면 람다 표현식보다 기존의 클래스 구현방식을 고수하는 것이 바람직할 수 있다.

### **의무 체인 (chain-of-responsibility)**

작업 처리 객체의 체인(동작 체인 등)을 만들 때는 의무 체인 패턴을 사용한다. 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달하는
식이다.

ProcessingObject 클래스를 상속받아 handleWork 메서드를 구현하여 다양한 종류의 작업 처리 객체를 만들 수 있다. 이때 작업 처리 객체를 UnaryOperator 형식의 인스턴스로 표현하여 사용할
수 있다.

### **팩토리 (factory)**

인스턴스화 로직을 클라이언트에게 노출하지 않고 객체를 만들 때 팩토리 디자인 패턴을 사용한다. 분기문을 통해 상황에 맞는 객체를 만들어 전달하는 것 대신 input을 키 Supplier를 값으로 갖는 Map을
만들고, 그리고 Supplier로는 생성자 메서드 참조를 사용하여 팩토리 패턴을 사용할 수 있다.

## **람다 테스팅**

람다에 대해서도 단위 테스팅(unit testing)이 작성되어야만 한다. 하지만 람다는 익명이므로 테스트 코드 이름을 호출할 수 없다. 대신 람다 표현식은 함수형 인터페이스의 인스턴스를 생성한다. 따라서 인스턴스의
동작으로 람다 표현식을 테스트할 수 있다.

람다의 목표는 정해진 동작을 다른 메서드에서 사용할 수 있도록 하나의 조각으로 캡슐화하는 것이다. 그러려면 세부 구현을 포함하는 람다 표현식을 공개하지 말아야 한다.

결국 람다에 대한 테스팅은 세세한 람다의 동작 스텝 과정마다의 산출물이 아닌 전체 람다 표현식에 대하여 입력한 input과 기대하는 output이 잘 반환되는지에 대한 테스트가 필요하다.

복잡한 람다 표현식이라면 개별 메서드로 분할하여 테스트 단위를 잘게 쪼개는 것이다. 또한 함수를 인수로 받거나 다른 함수를 반환하는 메서드라면 테스트 내에서 또 다른 람다를 사용해서 테스트하자.

## **디버깅**

### **스택 트레이스 확인**

람다 표현식은 이름이 없기 때문에 조금 복잡한 스택 트레이스가 생성된다. 그렇기에 람다 표현식과 관련된 스택 트레이스는 이해하기 어려울 수 있다. 이는 미래의 자바 컴파일러가 개선해야 할 부분이다.

### **정보 로깅**

forEach를 통해 스트림 결과를 출력하거나 로깅할 수 있다. 하지만 forEach는 스트림을 소비하는 연산이다. 스트림 파이프라인에 적용된 각각의 연산의 결과를 확인할 수 있다면 대신 peek라는 스트림 연산을
활용할 수 있다. peek는 스트림의 각 요소를 소비한것 처럼 동작을 실행하지만, 실제로 스트림을 소비하지않고 자신이 확인한 요소를 파이프라인의 다음 연산으로 그대로 전달한다.

# **Chapter 10 - 람다를 이용한 도메인 전용 언어**

## **도메인 전용 언어 (domain-specific language, DSL)**

- 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어
- 특정 비스니스 도메인을 인터페이스로 만든 API
- 도메인을 표현할 수 있는 클래스와 메서드 집합이 필요하다

### **DSL의 장점**

- 간결함 : API는 비즈니스 로직을 간편하게 캡슐화하므로 반복을 피할 수 있고 코드를 간결하게 만들 수 있다.
- 가독성 : 도메인 영역의 용어를 사용하므로 비 도메인 전문가도 코드를 쉽게 이해할 수 있다. 다양한 조직 구성원 간에 코드와 도메인 영역이 공유될 수 있다.
- 유지보수 : 잘 설계된 DSL로 구현한 코드는 쉽게 유지보수하고 바꿀 수 있다.
- 높은 수준의 추상화 : DSL은 도메인과 같은 추상화 수준에서 동작하므로 도메인의 문제와 직접적으로 관련되지 않은 세부 사항을 숨긴다.
- 집중 : 비즈니스 도메인의 규칙을 표현할 목적으로 설계된 언어이므로 프로그래머가 특정 코드에 집중할 수 있다.
- 관심사분리(SoC) : 지정된 언어로 비즈니스 로직을 표현함으로 애플리케이션의 인프라구조와 관련된 문제와 독립적으로 비즈니스 관련된 코드에서 집중하기가 용이하다.

### **DSL의 단점**

- DSL 설계의 어려움 : 간결하게 제한적인 언어에 도메인 지식을 담는 것이 쉬운 작업은 아니다.
- 개발 비용 : 코드에 DSL을 추가하는 작업은 초기 프로젝트에 많은 비용과 시간이 소모된다. 또한 DSL 유지보수와 변경은 프로젝트에 부담을 주는 요소다.
- 추가 우회 계층 : DSL은 추가적인 계층으로 도메인 모델을 감싸며 이 때 계층을 최대한 작게 만들어 성능 문제를 회피한다.
- 새로 배워야 하는 언어 : DSL을 프로젝트에 추가하면서 팀이 배워야 하는 언어가 한 개 더 늘어난다는 부담이 있다.
- 호스팅 언어 한계 : 일부 자바 같은 범용 프로그래밍 언어는 장황하고 엄격한 문법을 가졌다. 이런 언어로는 사용자 친화적 DSL을 만들기가 힘들다.

## **JVM에서 이용할 수 있는 다른 DSL 해결책**

### **내부 DSL**

내부 DSL이란 자바로 구현한 DSL을 의미한다. 람다 표현식이 등장하며 쉽고 간단하며 표현력있는 DSL을 만들 수 있게 되었다. 익명 내무 클래스를 사용하는 것보다 람다를 사용하면 신호 대비 잡음 비율을 적정
수준으로 유지하는 DSL을 만들 수 있다.

- 외부 DSL에 비해 새로운 패턴과 기술을 배워 DSL을 구현할 필요가 없다
- 순수 자바로 DSL을 구현하면 나머지 코드와 함께 DSL을 컴파일할 수 있다.
- 개발팀이 새로운 언어를 배울 필요가 없다.
- 기존 자바 IDE를 통해 자동 완성, 자동 리팩터링 같은 기능을 그대로 사용할 수 있다.

### **다중 DSL**

같은 자바 바이트코드를 사용하는 JVM 기반 프로그래밍 언어를 이용하여 DSL을 만들 수 있다.

- 문법적 잡음이 없으며 개발자가 아닌 사람도 코드를 쉽게 이해할 수 있다.
- 자바 언어가 가지는 한계를 넘을 수 있다 (스칼라는 꼬리 호출 최적화를 통해 함수 호출을 스택에 추가하지 않는다).
- 누군가가 해당 언어에 대해 고급 기술을 사용할 수 있을 정도의 충분한 지식을 가지고 있어야 한다.
- 두 개 이상의 언어가 혼재하므로 여러 컴파일러로 소스를 빌드하도록 빌드 과정을 개선해야 한다.
- 호환성 문제를 고려해야한다

### **외부 DSL**

자신만의 문법과 구문으로 새 언어를 설계해야한다.

### **최신 자바 API의 작은 DSL**

- 스트림 API는 컬렉션을 조작하는 DSL
- 데이터를 수집하는 DSL인 Collectors

## **자바로 DSL을 만드는 패턴과 기법**

### **메서드 체인**

- 메서드 체인을 통해 객체를 만든다.
- 플루언트 API로 도메인 객체를 만드는 몇 개의 빌더를 구현해야 한다.
- 사용자가 미리 지정된 절차에 따라 설정하도록 한다.
- 사용한 파라미터가 빌더 내부로 국한된다.
- 정적 메서드 사용을 최소화하고 메서드 이름이 인수의 이름을 대신하도록 만들어 가독성이 좋다.
- 빌더를 구현하여야만 한다.

### **중첩된 함수 이용**

- 다른 함수안에 함수를 이용하여 도메인 모델을 만든다.
- DSL에 더 많은 괄호를 사용해야 한다
- 인수 목록을 정적 메서드에 넘겨주어야 한다
- 인수의 의미가 이름이 아니라 위치에 의해 정의된다

### **람다 표현식을 이용한 함수 시퀀싱**

- 메서드 체인 패턴처럼 플루언트 방식으로 정의가능하다
- 중첩 함수 형식처럼 람다 표현식의 중첩 수준과 비슷하게 도메인 객체의 계층 구조를 유지한다
- 많은 설정 코드가 필요하며, 람다 표현식 문법에 의한 잡음의 영향을 받는다.
