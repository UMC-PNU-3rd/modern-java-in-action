# <Part1 기초>

# 1장 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## 1.1 역사의 흐름은 무엇인가? (멀티코어 병렬성)

### 자바 8

- 요구사항
  - 간결한 코드
  - 멀티코어 프로세서의 쉬운 활용
- 기능
  - 스트림 API: 병렬 연산 지원
  - 메서드에 코드를 전달 (메서드 참조, 람다)
    → 동작 파라미터화 구현
    → 함수형 프로그래밍에서 활용 ⬆️
  - 인터페이스의 디폴트 메서드

### 자바 9

- 대규모 컴포넌트
- 리액티브 프로그래밍 툴킷

### 자바 10

- 지역 변수 추론

### 자바 11

- 개선된 람다 표현식 인수 문법

## 1.2 왜 아직도 자바는 변화하는가? (메서드 참조)

### 자바가 성공한 이유

- 많은 유용한 라이브러리
- 객체지향 언어(캡슐화, 프로그래밍 모델에 쉽게 대응)
- 동시성 지원
- 모든 브라우저에서 가상 머신 코드 지원

### 변화해야 하는 이유

1. 빅데이터(테라바이트 이상) ⇒ 멀티코어, 컴퓨팅 클러스터
2. 객체지향 + 함수형 프로그래밍 ⇒ 2가지 장점 모두 활용 가능
3. 하드웨어, 프로그래머의 기대에 부응해야함

### 변화하는 자바

1. 스트림 처리: 스레드(복잡)를 사용하지 않고, 공짜로 병렬성 획득
2. 동작 파라미터화: 코드 일부를 다른 메서드의 인수로 넘김
3. 공짜 병렬성: 함수형 프로그래밍(공유된 가변 데이터X)

## 1.3 자바 함수 (병렬형 데이터 표현 및 처리)

### 함수형 프로그래밍

- 함수를 일급값으로 넘겨주는 프로그램(메서드 참조::)
  ```java
  // 프레디케이트
  public interface Predicate<T>{
  	boolean test(T t);
  }
  // 예시 사용코드: 사과  필터링
  filterApples( inventory, Apple::isGreenApple);
  ```
- 람다(익명 함수) 문법 형식으로 구현된 프로그램
  ```java
  filterApples( inventory, (Apple a) -> GREEN.equals( a.getColor() ) );
  ```
  한 번만 사용할 메서드는 정의를 구현할 필요 없음

## 1.4 스트림 API(디폴트 메서드)

### 왜 만들어졌는가?

- 멀티코어 CPU의 병렬성 때문에

### 어떻게 사용되는가?

- 복잡 모호한 컬렉션 API와는 다르게 간단하게 처리 가능
- 라이브러리 내부에서 모든 데이터 처리 가능(내부 반복)
- 멀티코어 활용 쉬움

### 컬렉션 API와의 차이점?

| 컬렉션 API             | 스트림 API                      |
| ---------------------- | ------------------------------- |
| 어떻게 저장, 접근할지  | 어떤 계산을 할지                |
| 모호함과 반복적인 코드 | 간단한 코드                     |
| 멀티코어 활용 어려움   | 멀티코어 활용 용이(병렬성 획득) |

## 1.5 디폴트 메서드와 자바 모듈(함수형 프로그래밍)

### 문제점

- 패키지 인터페이스의 변경시, 모든 클래스 구현을 바꿔야 함

### 해결

- 자바9 → 모듈 정의 문법을 제공
- 자바8 → 디폴트 메서드 지원(인터페이스 변경 용이하게 함)

### 생각할 거리

- 하나의 클래스에서 여러 인터페이스 구현 가능하면,
  여러 인터페이스에 다중 디폴트 메서드 존재 가능
  ⇒ 다중 상속이 허용되는가?
- 다이아몬드 상속 문제

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

- Optional<T>: NullPointer 예외 피할 수 있음
- 구조적 패턴 매칭: 완벽하게 지원X (다형성, 메서드 오버라이딩이 임시방편)
